

Growcontroller „GrowintelliPi“
Architektur Dokument

Inhaltsverzeichnis
1. Ziele und Kontext	8
1.1 Projektziele	8
1.2 Beteiligte und Schnittstellen	8
Beteiligte	8
Schnittstellen	8
Webinterface: 	8
I2C: 	9
ISO 14443: 	9
Serielle Schnittstelle: 	9
API für Module: 	9
Hardware-Schnittstellen: 	9
1.3 Kontextabgrenzung	9
Abgrenzung zu anderen Systemen:	10
Benutzerinteraktion:	10
Hardware-Abhängigkeiten:	10
2. Randbedingungen	10
2.1 Organisatorische Randbedingungen	10
Projektteam: 	10
Zeitplan: 	10
Budget: 	10
Ressourcen: 	11
Kommunikation: 	11
Qualitätssicherung: 	11
Dokumentation: 	11
Open-Source-Strategie: 	11
Ziele:* 	11
Maßnahmen:* 	11
Beispiele:* 	12
Kommerzielle Strategie: 	12
Zielgruppe:	12
Produkt:* 	12
Preisgestaltung:* 	12
Marketing:* 	12
Vertrieb:* 	12
Support:* 	12
Partnerschaften:* 	12
Beispiele:* 	13
Rechtliche Aspekte: 	13
Lizenzen:* 	13
Urheberrechte:* 	13
Patente:* 	13
Datenschutz:* 	13
Haftung:* 	13
Beispiele:* 	13
2.2 Technische Randbedingungen	14
Hardware	14
Raspberry Pi:	14
Sensoren: 	14
Aktoren: 	14
2.8" TFT Touch Display:	14
Stromversorgung:	14
Gehäuse:	14
Umgebung:	14
Software	14
Python:	14
Betriebssystem:	14
Datenbank:	15
Webframework:	15
Kompatibilität:	15
Update-Mechanismus:	15
Entwicklungsumgebung	15
VSCode:	15
Weitere Tools:	15
Versionskontrolle:	15
3. Anforderungen	15
3.1 Funktionale Anforderungen	15
3.1.1 Initialisierung/Konfiguration	15
3.1.2 Sensorerfassung	16
Als Benutzer möchte ich die aktuellen Messwerte der Sensoren auf dem Dashboard angezeigt bekommen. 	16
Als Benutzer möchte ich historische Sensordaten in Form von Diagrammen anzeigen lassen können. 	16
Als Benutzer möchte ich die Rohdaten der Sensoren einsehen können. 	16
3.1.3 Aktorensteuerung	17
Als Benutzer möchte ich die Aktoren manuell über das Webinterface ein- und ausschalten können. 	17
Als Benutzer möchte ich Aktoren zeitgesteuert schalten können. 	17
Als Benutzer möchte ich Aktoren automatisch in Abhängigkeit von Sensorwerten steuern können. 	17
3.1.4 Benutzeroberfläche (Webinterface)	17
Als Benutzer möchte ich ein übersichtliches Dashboard mit allen wichtigen Informationen sehen. 	17
Als Benutzer möchte ich die Konfiguration des Systems über das Webinterface verändern können. 	17
Als Benutzer möchte ich auf die Logdateien des Systems zugreifen können. 	17
3.1.5 Update-Funktionalität	18
Als Benutzer möchte ich das System manuell auf Updates prüfen und diese installieren können. 	18
Als Benutzer möchte ich automatische Updates aktivieren können. 	18
Als Benutzer möchte ich im Fehlerfall ein Rollback durchführen können. 	18
3.1.6 Sicherheit	18
Als Benutzer möchte ich den Zugriff auf das System mit einem Passwort schützen können. 	18
Als Benutzer möchte ich verschiedene Benutzerrollen mit unterschiedlichen Berechtigungen haben. 	18
3.1.7 Factory Reset	19
Als Benutzer möchte ich das System auf die Werkseinstellungen zurücksetzen können. 	19
3.1.8 Backup/Restore (Zukünftige Funktion)	19
Als Benutzer möchte ich die Konfiguration und Daten des Systems sichern und wiederherstellen können. 	19
3.2 Nicht-funktionale Anforderungen	19
Performance:	19
Sicherheit:	19
Benutzerfreundlichkeit:	19
Zuverlässigkeit:	19
4. Architektonische Entscheidungen	20
4.1 Architekturstil	20
Entscheidung:	20
Begründung:	20
Alternativen:	20
Konsequenzen:	20
4.2 Technologieauswahl	20
Entscheidung:	20
Begründung:	20
Alternativen:	21
Konsequenzen:	21
4.3 Design Patterns	21
Entscheidung:	21
Begründung:	21
Alternativen:	21
Konsequenzen:	21
4.4 Datenmanagement	21
Entscheidung:	21
Begründung:	22
Alternativen:	22
Konsequenzen:	22
4.5 Sicherheit	22
Entscheidung:	22
Begründung:	22
Alternativen:	22
Konsequenzen:	22
4.6 Deployment	23
Entscheidung:	23
Begründung:	23
Alternativen:	23
Konsequenzen:	23
4.7 Wartung	23
Entscheidung:	23
Begründung:	23
Alternativen:	23
Konsequenzen:	23
5. Bausteinsicht	23
5.1 Hauptprogramm (Controller)	24
Aufgabe:	24
Schnittstellen:	24
Daten:	24
5.2 Webinterface-Modul	24
Aufgabe:	24
Schnittstellen:	24
Daten:	24
5.3 Sensor-Module	24
Aufgabe:	24
Schnittstellen:	25
Daten:	25
5.4 Aktor-Module	25
Aufgabe:	25
Schnittstellen:	25
Daten:	25
5.5 Datenbank-Modell	25
Aufgabe:	25
Schnittstellen:	25
Daten:	25
5.6 Update-Modul	25
Aufgabe:	25
Schnittstellen:	25
Daten:	26
5.7 Plugin-System	26
Aufgabe:	26
Schnittstellen:	26
Daten:	26
Diagramm 	26
6. Laufzeitsicht	26
6.1 Anzeigen der aktuellen Sensorwerte	26
6.2 Automatische Bewässerung	27
6.3 Konfiguration des Systems	27
7. Verteilungssicht	28
7.1 Hardware-Diagramm 	28
7.2 Software-Diagramm	28
7.3 Kommunikationswege	28
I2C:	28
GPIO:	28
HTTP/WebSockets:	28
SQLite:	29
7.4 Netzwerk	29
7.5 Deployment	29
8. Implementierungssicht (muss noch deutlich verfeinert werden.)	29
8.1 Code-Struktur	29
Dateinamen:	30
Klassennamen:	30
Funktionsnamen:	30
8.2 Module und Komponenten	30
Webinterface-Modul:* 	31
8.3 Bibliotheken und Frameworks	31
Django:	32
SQLite:	32
8.4 Datenstrukturen und Algorithmen	32
8.5 Schnittstellen	32
8.6 Teststrategie	32
8.7 Build-Prozess	33
8.8 Deployment	33
8.9 Code-Beispiele	33
9. Daten	33
9.1 Datenmodell	33
Sensor:* 	33
Aktor:* 	33
Benutzer:* 	33
Messwert:* 	34
Konfiguration:* 	34
9.2 Datenformate	34
JSON:	34
SQLite:	34
9.3 Datenquellen	34
Sensoren:	34
Benutzer:	34
9.4 Datenspeicherung	35
9.5 Datenzugriff	35
9.6 Datenschutz	35
9.7 Datenqualität	35
Validierung:	35
Plausibilitätsprüfung:	35
Fehlerbehandlung:	35
9.8 Datenmenge	36
Konfiguration:	36
Messwerte:	36
Benutzerdaten:	36
10. Schlüsselentscheidungen	36
10.1 Modulare Architektur:	36
Entscheidung:	36
Begründung:	36
Konsequenzen:	36
10.2 Technologieauswahl:	37
Entscheidung:	37
Begründung:	37
Konsequenzen:	37
10.3 Datenmanagement:	37
Entscheidung:	37
Begründung:	37
Konsequenzen:	37
10.4 Sicherheit:	37
Entscheidung:	37
Begründung:	37
Konsequenzen:	38
10.5 Update-Mechanismus:	38
Entscheidung:	38
Begründung:	38
Konsequenzen:	38
11. Komerzielle Strategie	38
Zielgruppe	38
Produktpositionierung	38
Preisgestaltung	39
Marketingstrategie	39
Vertriebskanäle	39
Kunden-Support	39
Partnerschaften	40
12. Technische Umsetzung	41
12.1 Ordnerstrucktur	41
12.2 Wireframes	42
12.2.1 Dashboard	42
12.2.2 Konfiguration	43
12.2.3 Diagramme	44
12.2.4 Logdateien	45
12.2.5 Update	46
12.2.6 Hilfe	47
13. Glossar	47
14. Änderungsprotokoll	50




1. Ziele und Kontext
1.1 Projektziele
Ziel des Projekts ist die Entwicklung eines intelligenten Grow Controllers, der eine flexible und benutzerfreundliche Steuerung von Sensoren und Aktoren in einer Pflanzenumgebung ermöglicht. Dabei sollen folgende Ziele erreicht werden:
Funktionalität: Unterstützung einer Vielzahl von Sensoren und Aktoren, einfache Konfiguration und Steuerung über ein Webinterface, automatische und manuelle Steuerungsmöglichkeiten, Update-Funktionalität, Sicherheitsmechanismen. 
Benutzerfreundlichkeit: Intuitive Bedienung, übersichtliche Darstellung der Informationen, einfache Installation und Konfiguration. 
Zuverlässigkeit: Stabiler Betrieb, zuverlässige Messwerte, automatische Wiederaufnahme des Betriebs nach Stromausfällen. 
Wartbarkeit: Modularer Code, einfache Erweiterbarkeit und Wartung, gute Dokumentation. 
Skalierbarkeit: Unterstützung einer wachsenden Anzahl von Sensoren und Aktoren. 
Sicherheit: Schutz vor unbefugtem Zugriff und Manipulation. 
Energieeffizienz: Minimierung des Stromverbrauchs. 
Es ist noch nicht entschieden welche Lizenzform genutzt werden soll.
Open-Source-Aspekte: Förderung der Community-Beteiligung, Transparenz, Zusammenarbeit (falls zutreffend). 
Kommerzielle Aspekte: Generierung von Einnahmen durch den Verkauf des Hauptprogramms (falls zutreffend).

1.2 Beteiligte und Schnittstellen
Beteiligte
Benutzer: Hobbygärtner, die ihre eigenen Smart-Grow-Lösungen realisieren möchten. 
Entwickler: Verantwortlich für die Entwicklung, Wartung und Erweiterung des Systems. 
Open-Source-Community: (Falls zutreffend) Beteiligung an der Entwicklung, Bereitstellung von Modulen/Plugins, Feedback. 
Hardware-Lieferanten: Lieferanten der Hardware-Komponenten (Sensoren, Aktoren, Raspberry Pi). 
Tester: (Falls zutreffend) Externe Tester oder Qualitätssicherung. 
Schnittstellen
Webinterface: 
Technologien: HTML, CSS, JavaScript, Django-Framework 
Daten: Sensorwerte, Aktorzustände, Konfigurationseinstellungen 
Protokolle: HTTP, WebSockets 
Authentifizierung: Benutzername/Passwort, optionale Zugangsberechtigung 
Eingänge: 
Eingang 1-3: DHT11 oder DHT22 
Eingang 4-6: Bodenfeuchtesensoren 
Eingang 7-8: Wassertank-Füllstandssensoren 
Eingang 9-10: Beleuchtungssensoren 
Serielle Schnittstelle: 
Zwecke: Debugging, alternative IP-Anzeige 
Daten: Logmeldungen, Statusinformationen 
API für Module: 
Schnittstellen zur Entwicklung von Sensor- und Aktor-Modulen 
Dokumentation der API 
Hardware-Schnittstellen: 
Anschlüsse für Sensoren (analog/digital) 
Anschlüsse für Aktoren (Relais, PWM) 
2.8" TFT Touch Display (SPI)

1.3 Kontextabgrenzung
Der Intelligente Grow Controller konzentriert sich auf die Steuerung und Überwachung der inneren Pflanzenumgebung, primär in geschlossenen Systemen wie Grow-Zelten oder Gewächshäusern. Folgende Aspekte werden nicht abgedeckt:
Äußere Umgebungsbedingungen: Das System berücksichtigt keine Wetterdaten oder andere äußere Einflüsse. 
Pflanzenpflege: Das System gibt keine Empfehlungen zur Pflanzenpflege (z.B. Düngen, Beschneiden). 
Bewässerungssysteme: Die Steuerung der Bewässerung mittels einfacher Pumpen ist ein zentrales Feature des Intelligenten Grow Controllers. Das System ermöglicht die Ansteuerung von Pumpen zur Bewässerung der Pflanzen, beispielsweise zeitgesteuert oder in Abhängigkeit von Sensordaten (z.B. Bodenfeuchtigkeit). Einfache Pumpensteuerung umfasst das Ein- und Ausschalten von Pumpen basierend auf Zeitplänen oder Sensorwerten.
Komplexe Bewässerungssysteme mit mehreren Zonen, differenzierter Nährstoffzugabe oder anderen fortgeschrittenen Funktionen werden nicht direkt unterstützt. Komplexe Bewässerungssysteme umfassen beispielsweise Systeme mit mehr als drei Bewässerungszonen oder Systeme mit automatischer Nährstoffdosierung. Die Ansteuerung solcher Systeme kann jedoch potenziell über die vorhandenen Pumpensteuerungsfunktionen und unter Nutzung der modularen Architektur durch entsprechende Erweiterungen realisiert werden.

Klimatisierung: Die Steuerung von Klimaanlagen oder Heizungen ist nicht direkt integriert. 
Nährstoffversorgung: Die automatische Dosierung von Nährstoffen wird nicht unterstützt. 
Bestandsverwaltung: Die Verwaltung von Saatgut, Dünger oder anderen Materialien gehört nicht zum Funktionsumfang. 
Abgrenzung zu anderen Systemen:
Cloud-Dienste: Das System kommuniziert nicht mit Cloud-Diensten zur Datenspeicherung oder -verarbeitung. Alle Daten werden lokal auf dem Raspberry Pi gespeichert. 
Mobile Apps: Es gibt keine separate mobile App zur Steuerung des Grow Controllers. Die Bedienung erfolgt ausschließlich über das Webinterface. 
Hausautomatisierung: Der Grow Controller ist nicht in ein größeres Hausautomatisierungssystem integriert. 
Benutzerinteraktion:
Die primäre Interaktion erfolgt über das Webinterface. Zusätzlich kann die serielle Schnittstelle für Debugging-Zwecke genutzt werden. Das 2.8" TFT Touch Display dient zur Anzeige der IP-Adresse und grundlegender Statusinformationen.
Hardware-Abhängigkeiten:
Das System ist primär für den Einsatz auf Raspberry Pi Generation 2 oder höher konzipiert. Die Unterstützung anderer Hardware-Plattformen ist nicht vorgesehen. Bestimmte Sensortypen oder Aktoren, die spezielle Treiber oder Protokolle erfordern, werden möglicherweise nicht unterstützt. Eine Liste der unterstützten Hardware-Komponenten wird in der Dokumentation geführt.
2. Randbedingungen
2.1 Organisatorische Randbedingungen
Projektteam: 
James Salzer (Entwickler, Architekt) 
(Vieleicht kommen weitere Teammitglieder dazu) 
Zeitplan: 
(noch nicht geplant) 
Budget: 
(wie Zeitplan, noch nicht geplant) 
Ressourcen: 
Hardware: Raspberry Pi, Sensoren, Aktoren 
Software: Python, Django, SQLite 
Personal: (1 Entwickler) 
Kommunikation: 
Intern: E-Mail, TODO Liste 
Extern (Open-Source-Community): Forum, Chat, GitHub Issues 
Qualitätssicherung: 
Code-Reviews, Unit-Tests, Integrationstests 
Dokumentation: 
Benutzerhandbuch, Entwicklerdokumentation, API-Dokumentation 
Open-Source-Strategie: 
Ziele:* 
Community-Building: Aufbau einer aktiven Community von Entwicklern und Nutzern, die zur Weiterentwicklung des Projekts beitragen. 
Transparenz: Offenlegung des Quellcodes und der Entwicklungsprozesse, um Vertrauen zu schaffen und die Zusammenarbeit zu fördern. 
Qualität: Verbesserung der Softwarequalität durch die Beteiligung der Community (z.B. durch Code-Reviews, Bug-Reports). 
Innovation: Generierung neuer Ideen und Funktionen durch die Zusammenarbeit mit der Community. 
Reichweite: Erhöhung der Reichweite des Projekts durch die freie Verfügbarkeit des Quellcodes. 
Maßnahmen:* 
Lizenzierung: Auswahl einer geeigneten Open-Source-Lizenz (z.B. MIT, Apache, GPL), die die kommerzielle Nutzung erlaubt. 
Repository: Einrichtung eines öffentlichen Repository (z.B. auf GitHub, GitLab) für den Quellcode und die Dokumentation. 
Community-Plattformen: Schaffung von Kommunikationskanälen (z.B. Foren, Chat, Mailinglisten) für die Community. 
Beiträge: Definition von Richtlinien für Beiträge (z.B. Code-Konventionen, Pull-Request-Prozess). 
Anerkennung: Anerkennung der Beiträge der Community (z.B. durch Nennung der Mitwirkenden). 
Roadmap: Veröffentlichung einer Roadmap für die Weiterentwicklung des Projekts. 
Beispiele:* 
Das Projekt könnte regelmäßig Hackathons oder Contests veranstalten, um die Community zu aktivieren. 
Es könnte eine "Contributor Ladder" eingeführt werden, um die verschiedenen Rollen und Verantwortlichkeiten in der Community zu definieren.

Kommerzielle Strategie: 
Zielgruppe:
Hobbygärtner
professionelle Züchter
Forschungseinrichtungen
Produkt:* 
Welche Funktionen und Vorteile bietet das kommerzielle Hauptprogramm gegenüber der Open-Source-Version? (z.B. erweiterte Funktionen, Support, Schulungen). 
Preisgestaltung:* 
Wie wird der Preis für das kommerzielle Hauptprogramm festgelegt? (z.B. einmalige Lizenzgebühr, Abonnement, gestaffelte Preise). 
Marketing:* 
Wie wird das kommerzielle Hauptprogramm beworben? (z.B. Online-Marketing, Messen, Konferenzen). 
Vertrieb:* 
Wie wird das kommerzielle Hauptprogramm verkauft? (z.B. Online-Shop, Vertriebspartner). 
Support:* 
Welchen Support wird den Kunden geboten? (z.B. E-Mail-Support, Telefon-Support, Online-Dokumentation). 
Partnerschaften:* 
Gibt es potenzielle Partner, mit denen das Projekt zusammenarbeiten könnte? (z.B. Hardware-Hersteller, Anbieter von Grow-Zubehör). 
Beispiele:* 
Das kommerzielle Hauptprogramm wird erweiterte Analysefunktionen und Integration mit anderen Systemen bieten. 
Es könnte verschiedene Lizenzmodelle angeboten werden, z.B. eine kostenlose Version mit eingeschränkter Funktionalität und eine kostenpflichtige Version mit vollem Funktionsumfang.

Rechtliche Aspekte: 
Lizenzen:* 
Welche Lizenzen werden für die verschiedenen Komponenten des Systems verwendet? (z.B. Open-Source-Lizenzen für Module, kommerzielle Lizenz für das Hauptprogramm). 
Sind die Lizenzen kompatibel miteinander? 
Urheberrechte:* 
Wer besitzt die Urheberrechte an den verschiedenen Komponenten des Systems? 
Wie werden die Urheberrechte geschützt? 
Patente:* 
Gibt es Patente, die im Zusammenhang mit dem System relevant sind? 
Datenschutz:* 
Welche Daten werden vom System erfasst und wie werden sie verarbeitet? 
Werden die Datenschutzbestimmungen eingehalten (z.B. DSGVO)? 
Haftung:* 
Wer ist für Schäden verantwortlich, die durch das System verursacht werden? 
Gibt es Haftungsbeschränkungen? 
Beispiele:* 
Es sollte sichergestellt werden, dass die Open-Source-Lizenzen der verwendeten Module mit der kommerziellen Lizenz des Hauptprogramms kompatibel sind. 
Es könnte eine Datenschutzerklärung erstellt werden, die die Benutzer über die Datenerfassung und -verarbeitung informiert.
2.2 Technische Randbedingungen
Hardware
Raspberry Pi:
Raspberry Pi 2, 3 oder 4 (genaue Modelle werden in der Hardware-Dokumentation spezifiziert) 
Sensoren: 
DHT11/22 (Temperatur/Luftfeuchtigkeit) 
Bodenfeutesensor
Wassertankfüllstandsensor
Beläuchtungssensoren
Aktoren: 
Relaismodule (220V-Geräte) 
PWM-Controller für LEDs 
(Weitere unterstützte Aktoren werden in der Hardware-Dokumentation aufgeführt) 
2.8" TFT Touch Display:
(Genaues Modell wird in der Hardware-Dokumentation spezifiziert) 
Stromversorgung:
5V über Micro-USB oder GPIO-Pins, (genaue Anforderungen werden in der Hardware-Dokumentation spezifiziert) 
Gehäuse:
(Anforderungen an Größe, Material und Schutzart werden in der Hardware-Dokumentation spezifiziert) 
Umgebung:
Einsatz in Innenräumen bei Temperaturen zwischen 15°C und 30°C und einer Luftfeuchtigkeit zwischen 30% und 70% 
Software
Python:
Python 3.9+ mit den Bibliotheken Django, (weitere Bibliotheken werden in der Software-Dokumentation aufgeführt) 
Betriebssystem:
Raspberry Pi OS (aktuelle Version) 
Datenbank:
SQLite (Standardkonfiguration) 
Webframework:
Django 
Kompatibilität:
Kompatibilität mit den genannten Hardware-Komponenten und Betriebssystemen 
Update-Mechanismus:
Automatisches und manuelles Update über das Webinterface, Rollback-Funktion 
Entwicklungsumgebung
VSCode:
Empfohlen (mit den Plugins ... falls zutreffend) 
Weitere Tools:
Git für die Versionskontrolle, (weitere Tools werden bei Bedarf spezifiziert) 
Versionskontrolle:
Git, Repository auf GitHub/GitLab (falls zutreffend)"

3. Anforderungen
3.1 Funktionale Anforderungen
3.1.1 Initialisierung/Konfiguration
Bei der ersten Inbetriebnahme soll der Benutzer die WLAN-Zugangsdaten eingeben können. 
Akzeptanzkriterien: 
Eingabe von SSID und Passwort über das 2.8" TFT Touch Display. 
Validierung der Eingabe (z.B. Format, Länge). 
Fehlermeldung bei ungültiger Eingabe. 
Speicherung der Daten in der Konfiguration. 
Automatischer Neustart des Systems nach erfolgreicher Eingabe. 
Als Benutzer möchte ich die IP-Adresse des Systems auf dem Display und über die serielle Schnittstelle angezeigt bekommen. 
Akzeptanzkriterien: 
Anzeige der IP-Adresse im Klartext auf dem Display. 
Ausgabe der IP-Adresse über die serielle Schnittstelle. 
Automatische Aktualisierung der Anzeige bei Änderung der IP-Adresse. 
Als Benutzer möchte ich Sensoren einfach anschließen können. 
Akzeptanzkriterien: 
Sauber und eindeutig beschriftete Eingänge. 
Anzeige der Sensoren mit ID im Webinterface. 
Als Benutzer möchte ich Aktoren benennen und konfigurieren können. 
Akzeptanzkriterien: 
Eingabe von Aktor-Namen (max. 100 Zeichen, alphanumerisch, -, _). 
Zuordnung von Aktoren zu Ausgängen (Relais, PWM). 
Validierung der Eingabe (z.B. Format, Eindeutigkeit). 
Speicherung der Konfiguration in der Datenbank. 
3.1.2 Sensorerfassung
Als Benutzer möchte ich die aktuellen Messwerte der Sensoren auf dem Dashboard angezeigt bekommen. 
Akzeptanzkriterien: 
Anzeige von Temperatur, Luftfeuchtigkeit, Bodenfeuchtigkeit, etc. auf dem Dashboard. 
Automatische Aktualisierung der Werte in konfigurierbaren Intervallen. 
Anzeige von Messwerten in geeigneten Einheiten (°C, %, etc.). 
Als Benutzer möchte ich historische Sensordaten in Form von Diagrammen anzeigen lassen können. 
Akzeptanzkriterien: 
Auswahl von Zeitraum und Sensor für die Diagrammanzeige. 
Anzeige der Daten als Liniendiagramm oder andere geeignete Diagrammtypen. 
Möglichkeit, die Diagramme zu exportieren (z.B. als Bild oder CSV-Datei). 
Als Benutzer möchte ich die Rohdaten der Sensoren einsehen können. 
Akzeptanzkriterien: 
Zugriff auf eine Tabelle oder eine andere geeignete Darstellung der Rohdaten. 
Möglichkeit, die Rohdaten herunterzuladen. 
3.1.3 Aktorensteuerung
Als Benutzer möchte ich die Aktoren manuell über das Webinterface ein- und ausschalten können. 
Akzeptanzkriterien: 
Schaltfläche oder anderer geeigneter Mechanismus für jeden Aktor im Webinterface. 
Anzeige des aktuellen Zustands (Ein/Aus) des Aktors. 
Sofortige Reaktion des Aktors auf manuelle Steuerung. 
Als Benutzer möchte ich Aktoren zeitgesteuert schalten können. 
Akzeptanzkriterien: 
Erstellung von Zeitplänen mit Start- und Endzeit für jeden Aktor. 
Auswahl von Wochentagen für die Aktivierung des Zeitplans. 
Möglichkeit, mehrere Zeitpläne für einen Aktor zu erstellen. 
Als Benutzer möchte ich Aktoren automatisch in Abhängigkeit von Sensorwerten steuern können. 
Akzeptanzkriterien: 
Definition von Regeln, die Sensorwerte und Aktorzustände verknüpfen (z.B. "Wenn Temperatur > 25°C, dann schalte Lüfter ein"). 
Möglichkeit, Schwellwerte und Hysterese für die Regeln festzulegen. 
3.1.4 Benutzeroberfläche (Webinterface)
Als Benutzer möchte ich ein übersichtliches Dashboard mit allen wichtigen Informationen sehen. 
Akzeptanzkriterien: 
Anzeige der aktuellen Sensorwerte (Temperatur, Luftfeuchtigkeit, etc.). 
Anzeige der Zustände der Aktoren (Ein/Aus). 
Einfache Navigation zu anderen Seiten (z.B. Konfiguration, Diagramme). 
Responsives Design für verschiedene Bildschirmgrößen. 
Als Benutzer möchte ich die Konfiguration des Systems über das Webinterface verändern können. 
Akzeptanzkriterien: 
Zugriff auf alle Konfigurationsoptionen (Sensoren, Aktoren, Zeitpläne, etc.). 
Einfache und intuitive Bedienung der Konfigurationsformulare. 
Validierung der Eingaben. 
Als Benutzer möchte ich auf die Logdateien des Systems zugreifen können. 
Akzeptanzkriterien: 
Anzeige der Logdateien im Webinterface. 
Möglichkeit, die Logdateien herunterzuladen. 
3.1.5 Update-Funktionalität
Als Benutzer möchte ich das System manuell auf Updates prüfen und diese installieren können. 
Akzeptanzkriterien: 
Schaltfläche oder anderer Mechanismus zum Starten der Update-Prüfung. 
Anzeige verfügbarer Updates mit Versionsnummer und Beschreibung. 
Möglichkeit, die Updates auszuwählen, die installiert werden sollen. 
Fortschrittsanzeige während des Updates. 
Erfolgsmeldung oder Fehlermeldung nach dem Update. 
Als Benutzer möchte ich automatische Updates aktivieren können. 
Akzeptanzkriterien: 
Option zum Aktivieren/Deaktivieren automatischer Updates. 
Konfigurierbarer Zeitplan für automatische Updates (z.B. täglich, wöchentlich). 
Als Benutzer möchte ich im Fehlerfall ein Rollback durchführen können. 
Akzeptanzkriterien: 
Möglichkeit, zu einer vorherigen Version des Systems zurückzukehren. 
Auswahl der Version, auf die zurückgerollt werden soll. 
3.1.6 Sicherheit
Als Benutzer möchte ich den Zugriff auf das System mit einem Passwort schützen können. 
Akzeptanzkriterien: 
Eingabe von Benutzername und Passwort beim Zugriff auf das Webinterface. 
Verschlüsselung der Passwörter bei der Speicherung. 
Möglichkeit, das Passwort zu ändern. 
Als Benutzer möchte ich verschiedene Benutzerrollen mit unterschiedlichen Berechtigungen haben. 
Akzeptanzkriterien: 
Rollenbasierte Zugriffskontrolle (z.B. Administrator, Benutzer, Gast). 
Definition von Berechtigungen für jede Rolle (z.B. Konfiguration, Steuerung, Anzeige). 
3.1.7 Factory Reset
Als Benutzer möchte ich das System auf die Werkseinstellungen zurücksetzen können. 
Akzeptanzkriterien: 
Bestätigung des Factory Reset vor der Durchführung. 
Löschung aller Konfigurationseinstellungen und Daten. 
Wiederherstellung des Auslieferungszustands. 
3.1.8 Backup/Restore (Zukünftige Funktion)
Als Benutzer möchte ich die Konfiguration und Daten des Systems sichern und wiederherstellen können. 
Akzeptanzkriterien: 
Möglichkeit, ein Backup der Konfiguration und Daten zu erstellen. 
Möglichkeit, ein Backup wiederherzustellen. 
Auswahl des Speicherorts für das Backup.

3.2 Nicht-funktionale Anforderungen
Performance:
"Die Reaktionszeit des Webinterfaces auf Benutzerinteraktionen soll im Durchschnitt 500ms nicht überschreiten und in 95% der Fälle unter 1 Sekunde liegen. Die Latenz bei der Sensorerfassung und Aktorensteuerung soll 1 Sekunde nicht überschreiten." 
Sicherheit:
"Die Passwörter der Benutzer sollen mit einem sicheren Hash-Algorithmus (z.B. bcrypt) verschlüsselt gespeichert werden. Das Webinterface soll vor Cross-Site-Scripting-Angriffen geschützt sein." 
Benutzerfreundlichkeit:
"Das Webinterface soll intuitiv und einfach zu bedienen sein. Die wichtigsten Funktionen sollen mit wenigen Klicks erreichbar sein. Es soll eine Online-Hilfe geben, die die Bedienung des Systems erklärt." 
Zuverlässigkeit:
"Die durchschnittliche Verfügbarkeit des Systems soll 99,9% betragen. Nach einem Stromausfall soll das System automatisch neu starten und den Betrieb mit den zuletzt gespeicherten Einstellungen wiederaufnehmen." 
4. Architektonische Entscheidungen
4.1 Architekturstil
Entscheidung:
Wir haben uns für eine modulare Architektur entschieden. 
Begründung:
Eine modulare Architektur bietet uns die größte Flexibilität für die Erweiterung und Wartung des Systems. Neue Funktionen (z.B. Unterstützung für weitere Sensoren oder Aktoren) können in separaten Modulen implementiert werden, ohne den Kern des Systems zu verändern. Dies erhöht die Wartbarkeit und reduziert das Risiko von unerwünschten Seiteneffekten bei Änderungen. Zudem ermöglicht die modulare Architektur die Integration von Open-Source-Modulen/Plugins, was für unser Projekt ein wichtiger Aspekt ist. 
Alternativen:
Alternativ hätten wir eine monolithische Architektur in Betracht ziehen können. Diese wäre einfacher zu implementieren gewesen, hätte aber die Flexibilität und Wartbarkeit des Systems eingeschränkt. Eine Microservice-Architektur wäre ebenfalls eine Option gewesen, hätte aber den Implementierungsaufwand und die Komplexität des Systems erhöht. Angesichts der Größe und des Umfangs unseres Projekts ist die modulare Architektur ein guter Kompromiss zwischen Einfachheit und Flexibilität. 
Konsequenzen:
Die modulare Architektur erfordert die Definition klarer Schnittstellen zwischen den Modulen. Dies ist zwar mit einem gewissen Aufwand verbunden, zahlt sich aber durch die erhöhte Flexibilität und Wartbarkeit aus. Zudem müssen wir uns für einen Mechanismus zum Laden und Verwalten der Module entscheiden (z.B. ein Plugin-System). 
4.2 Technologieauswahl
In diesem Abschnitt werden die für die Entwicklung des Growcontroller-Webinterfaces ausgewählten Technologien und die Gründe für ihre Auswahl detailliert beschrieben.
4.2.1 Frontend
Entscheidung:
Für die Entwicklung des Frontends werden folgende Technologien verwendet: HTML5, CSS, JavaScript und Bootstrap.
Begründung:
HTML5: HTML5 dient als Grundlage für die Struktur und den Inhalt des Webinterfaces. Es bietet neue semantische Elemente und APIs, die die Entwicklung moderner Webanwendungen erleichtern. 
CSS: CSS wird für die Gestaltung und das Styling des Webinterfaces verwendet. Es ermöglicht eine flexible und effiziente Gestaltung und sorgt für ein ansprechendes Aussehen. 
JavaScript: JavaScript wird für die Interaktivität und dynamischen Funktionen des Webinterfaces eingesetzt. Es ermöglicht die Manipulation des DOM, die Verarbeitung von Benutzerinteraktionen und die Kommunikation mit dem Backend. 
Bootstrap: Bootstrap ist ein CSS-Framework, das die Entwicklung responsiver und ansprechender Designs beschleunigt. Es bietet eine Vielzahl vorgefertigter Komponenten und Layouts, die die Gestaltung des Webinterfaces erleichtern. 
Alternativen:
React, Vue.js, Angular: Diese JavaScript-Frameworks/Bibliotheken bieten mehr Struktur und Funktionalität für komplexe Anwendungen, sind aber für den Anfang möglicherweise überdimensioniert. 
Tailwind CSS: Tailwind CSS ist ein Utility-First-CSS-Framework, das sehr flexibel ist, aber eine längere Einarbeitungszeit erfordert. 
4.2.2 Backend
Entscheidung:
Für die Entwicklung des Backends wird Python mit dem Flask-Framework verwendet.
Begründung:
Python ist eine vielseitige und beliebte Programmiersprache, die sich gut für die Entwicklung von Webanwendungen eignet. Flask ist ein leichtgewichtiges und flexibles Webframework, das ideal für kleinere bis mittlere Projekte ist. Es bietet die grundlegenden Funktionen für die Erstellung von Webanwendungen und lässt sich bei Bedarf erweitern.
Alternativen:
Django: Django ist ein umfangreiches Framework mit vielen Funktionen, aber für den Anfang möglicherweise zu komplex. 
Node.js: Node.js ist eine Alternative für die Backend-Entwicklung, erfordert aber Kenntnisse in JavaScript. 
4.2.3 Datenbank
Entscheidung:
Für die Speicherung der Daten wird SQLite verwendet.
Begründung:
SQLite ist eine einfache und leichtgewichtige Datenbank, die sich gut für kleinere Projekte eignet. Sie ist in der Lage, die erwartete Datenmenge effizient zu verarbeiten und bietet eine einfache Möglichkeit, Daten zu speichern und abzurufen.
Alternativen:
PostgreSQL, MySQL: Diese relationalen Datenbanken sind leistungsfähiger und skalierbarer, aber für den Anfang möglicherweise zu komplex. 
MongoDB: MongoDB ist eine NoSQL-Datenbank, die sich gut für unstrukturierte Daten eignet, aber für die Konfiguration und Sensordaten möglicherweise nicht die beste Wahl ist. 
4.2.4 Versionskontrolle
Entscheidung:
Für die Versionskontrolle des Codes wird Git verwendet.
Begründung:
Git ist ein weit verbreitetes und leistungsfähiges Versionskontrollsystem, das die Zusammenarbeit und die Verwaltung des Codes erleichtert. Es ermöglicht das Verfolgen von Änderungen, das Arbeiten in Branches und das Zusammenführen von Code.
Alternativen:
Andere Versionskontrollsysteme: Es gibt andere Versionskontrollsysteme wie Mercurial oder SVN, aber Git ist das am weitesten verbreitete und bietet die meisten Vorteile. 

4.3 Design Patterns
Entscheidung:
Wir werden das MVC-Pattern (Model-View-Controller) für die Strukturierung der Anwendung und das Plugin-Pattern für die Integration von Open-Source-Modulen verwenden. 
Begründung:
Das MVC-Pattern trennt die Anwendungslogik (Model) von der Darstellung (View) und der Steuerung (Controller). Dies erhöht die Wartbarkeit und Testbarkeit des Codes. Das Plugin-Pattern ermöglicht es uns, neue Module zur Laufzeit zu laden und zu integrieren, ohne den Kern des Systems zu verändern. Dies ist entscheidend für die Erweiterbarkeit des Systems durch Open-Source-Module. 
Alternativen:
Alternativ zum MVC-Pattern hätten wir das MVVM-Pattern (Model-View-ViewModel) verwenden können. Dieses Pattern ist besonders gut für die Entwicklung von Benutzeroberflächen geeignet, die viele Interaktionen mit dem Benutzer haben. Für unser Projekt ist das MVC-Pattern jedoch ausreichend. 
Konsequenzen:
Die Verwendung des MVC-Patterns erfordert eine klare Trennung der Verantwortlichkeiten zwischen den verschiedenen Komponenten. Die Verwendung des Plugin-Patterns erfordert die Definition klarer Schnittstellen für die Module. 
4.4 Datenmanagement
Entscheidung:
Wir verwenden SQLite als Datenbank zur Speicherung der Konfiguration, der Sensordaten und der Aktorzustände. 
Begründung:
SQLite ist eine leichtgewichtige und embedded Datenbank, die sich gut für den Einsatz auf einem Raspberry Pi eignet. Sie ist einfach zu installieren und zu konfigurieren und bietet dennoch ausreichend Funktionalität für unser Projekt. 
Alternativen:
Für größere Datenmengen oder komplexere Abfragen hätten wir PostgreSQL oder MySQL in Betracht ziehen können. Diese Datenbanken bieten mehr Funktionen und Skalierbarkeit als SQLite, wären aber für unser Projekt überdimensioniert. 
Konsequenzen:
Die Verwendung von SQLite ermöglicht uns eine einfache und unkomplizierte Datenhaltung. Für den Fall, dass die Anforderungen an die Datenbank in Zukunft steigen, könnten wir auf eine andere Datenbank migrieren. 
4.5 Sicherheit
Entscheidung:
Wir implementieren eine rollenbasierte Zugriffskontrolle mit Passwortschutz, um den Zugriff auf das System zu schützen. Die Passwörter werden mit einem sicheren Hash-Algorithmus (z.B. bcrypt) verschlüsselt gespeichert. 
Begründung:
Eine rollenbasierte Zugriffskontrolle ermöglicht es uns, verschiedene Benutzerrollen mit unterschiedlichen Berechtigungen zu definieren (z.B. Administrator, Benutzer, Gast). Dadurch können wir sicherstellen, dass nur autorisierte Benutzer auf bestimmte Funktionen oder Daten zugreifen können. Die Verschlüsselung der Passwörter mit einem sicheren Hash-Algorithmus schützt die Passwörter vor unbefugtem Zugriff, selbst wenn die Datenbank kompromittiert wird. 
Alternativen:
Alternativ hätten wir eine einfachere Zugriffskontrolle mit nur einem Benutzerkonto implementieren können. Dies wäre jedoch weniger sicher gewesen. 
Konsequenzen:
Die Implementierung einer rollenbasierten Zugriffskontrolle erfordert einen gewissen Aufwand bei der Entwicklung. Die Verschlüsselung der Passwörter mit einem sicheren Hash-Algorithmus ist jedoch relativ einfach zu implementieren und bietet einen hohen Sicherheitsgewinn. 
4.6 Deployment
Entscheidung:
Das System wird auf einem Raspberry Pi installiert und betrieben. Das Webinterface ist über das lokale Netzwerk erreichbar. 
Begründung:
Der Raspberry Pi ist eine kostengünstige und energieeffiziente Plattform, die sich gut für den Einsatz im Bereich der Heimautomatisierung eignet. Die Installation und Konfiguration des Systems auf einem Raspberry Pi ist relativ einfach. 
Alternativen:
Alternativ hätten wir das System auf einem anderen Embedded-System oder einem Server deployen können. Dies hätte jedoch höhere Kosten und einen höheren Konfigurationsaufwand bedeutet. 
Konsequenzen:
Die Verwendung eines Raspberry Pi schränkt die Ressourcen des Systems ein (z.B. Rechenleistung, Speicher). Dies sollte bei der Entwicklung berücksichtigt werden. 
4.7 Wartung
Entscheidung:
Das System wird über ein Webinterface aktualisiert. Es wird eine Rollback-Funktion implementiert, um im Fehlerfall auf eine vorherige Version zurückkehren zu können. 
Begründung:
Die Aktualisierung über das Webinterface ist für den Benutzer einfach und bequem. Die Rollback-Funktion stellt sicher, dass das System im Fehlerfall nicht beschädigt wird. 
Alternativen:
Alternativ hätten wir die Aktualisierung über die Kommandozeile oder ein anderes Tool implementieren können. Dies wäre jedoch weniger benutzerfreundlich gewesen. 
Konsequenzen:
Die Implementierung der Update-Funktion und der Rollback-Funktion erfordert einen gewissen Entwicklungsaufwand.

5. Bausteinsicht
Das System ist in folgende wesentliche Bausteine unterteilt:
5.1 Hauptprogramm (Controller)
Aufgabe:
Das Hauptprogramm ist die zentrale Steuereinheit des Systems. Es lädt die Konfiguration aus der Datenbank, initialisiert die anderen Module und steuert die Kommunikation zwischen ihnen. Es enthält die Hauptlogik für die Steuerung der Aktoren in Abhängigkeit von den Sensordaten und den konfigurierten Regeln. 
Schnittstellen:
Schnittstelle zur Datenbank (für Konfiguration und Daten). 
Schnittstellen zu den Sensor-Modulen (für Sensorwerte). 
Schnittstellen zu den Aktor-Modulen (für Steuerung). 
Schnittstelle zum Webinterface-Modul (für Benutzerinteraktion). 
Schnittstelle zum Update-Modul (für Updates). 
Daten:
Konfigurationseinstellungen, aktuelle Sensorwerte, Aktorzustände, Regeln für die automatische Steuerung. 
5.2 Webinterface-Modul
Aufgabe:
Dieses Modul stellt die webbasierte Benutzeroberfläche für die Interaktion mit dem System bereit. Es zeigt die Sensorwerte und Aktorzustände an, ermöglicht die Konfiguration des Systems und bietet Zugriff auf die Logdateien. 
Schnittstellen:
Schnittstelle zum Hauptprogramm (für Daten und Befehle). 
Schnittstelle zum Benutzer (über HTTP/WebSockets). 
Daten:
Vom Benutzer eingegebene Konfigurationseinstellungen, angeforderte Daten (z.B. Diagramme). 
5.3 Sensor-Module
Aufgabe:
Jedes Sensor-Modul ist für die Kommunikation mit einem bestimmten Sensortyp zuständig. Es liest die Daten vom Sensor, verarbeitet sie und stellt sie dem Hauptprogramm zur Verfügung. 
Schnittstellen:
Schnittstelle zum Hauptprogramm (für Sensorwerte). 
Schnittstelle zum Sensor. 
Daten:
Rohdaten vom Sensor, verarbeitete Sensorwerte. 
5.4 Aktor-Module
Aufgabe:
Jedes Aktor-Modul steuert einen bestimmten Aktortyp. Es empfängt Befehle vom Hauptprogramm und setzt diese in Aktionen um (z.B. Schalten eines Relais, Anpassen der PWM-Frequenz). 
Schnittstellen:
Schnittstelle zum Hauptprogramm (für Befehle). 
Schnittstelle zum Aktor (über GPIO-Pins oder andere). 
Daten:
Befehle vom Hauptprogramm, Statusinformationen vom Aktor. 
5.5 Datenbank-Modell
Aufgabe:
Dieses Modul definiert die Struktur der SQLite-Datenbank, in der die Konfiguration, die Sensordaten und die Aktorzustände gespeichert werden. 
Schnittstellen:
Schnittstelle zum Hauptprogramm (für Datenzugriff). 
Daten:
Konfigurationseinstellungen, Sensorwerte, Aktorzustände, Zeitpläne, Benutzerdaten. 
5.6 Update-Modul
Aufgabe:
Dieses Modul ist für die Durchführung von Updates zuständig. Es prüft auf verfügbare Updates, lädt sie herunter, installiert sie und führt gegebenenfalls ein Rollback durch. 
Schnittstellen:
Schnittstelle zum Hauptprogramm (für Update-Befehle und Status). 
Schnittstelle zum Update-Server (für das Herunterladen von Updates). 
Schnittstelle zum Webinterface-Modul (für die Benutzerinteraktion). 
Daten:
Update-Pakete, Versionsinformationen, Update-Protokoll. 
5.7 Plugin-System
Aufgabe:
Das Plugin-System ermöglicht das dynamische Laden und Verwalten von Open-Source-Modulen/Plugins. Es stellt Schnittstellen bereit, über die neue Module in das System integriert werden können. 
Schnittstellen:
Schnittstelle zum Hauptprogramm (für das Laden und Entladen von Modulen). 
Schnittstellen zu den Modulen (für die Kommunikation). 
Daten:
Informationen über verfügbare Module, Konfiguration der Module.
Diagramm 

6. Laufzeitsicht
Im Folgenden werden einige typische Nutzungsszenarien des Grow Controllers beschrieben:
6.1 Anzeigen der aktuellen Sensorwerte
1. Aktor: Benutzer 
2. Aktion: Der Benutzer ruft das Webinterface des Grow Controllers über einen Webbrowser auf. 
3. System: Das Webinterface-Modul empfängt die Anfrage und authentifiziert den Benutzer (falls erforderlich). 
4. System: Das Webinterface-Modul fordert die aktuellen Sensorwerte vom Hauptprogramm an. 
5. System: Das Hauptprogramm fragt die Sensorwerte von den entsprechenden Sensor-Modulen ab. 
6. System: Die Sensor-Module lesen die Daten von den Sensoren und senden sie an das Hauptprogramm. 
7. System: Das Hauptprogramm verarbeitet die Sensorwerte und sendet sie an das Webinterface-Modul. 
8. System: Das Webinterface-Modul aktualisiert die Anzeige der Sensorwerte auf dem Dashboard. 
9. Aktor: Der Benutzer sieht die aktuellen Sensorwerte im Webbrowser. 
6.2 Automatische Bewässerung
1. Aktor: System (automatisch, periodisch) 
2. Aktion: Das Hauptprogramm prüft in regelmäßigen Abständen (z.B. alle 10 Minuten) die Bodenfeuchtigkeit. 
3. System: Das Hauptprogramm fragt den Wert des Bodenfeuchtigkeitssensors vom entsprechenden Sensor-Modul ab. 
4. System: Das Sensor-Modul liest die Daten vom Sensor und sendet sie an das Hauptprogramm. 
5. System: Das Hauptprogramm vergleicht den Wert der Bodenfeuchtigkeit mit einem konfigurierten Schwellwert. 
6. System: Wenn die Bodenfeuchtigkeit unter den Schwellwert fällt, sendet das Hauptprogramm einen Befehl an das Aktor-Modul für die Bewässerungspumpe. 
7. System: Das Aktor-Modul schaltet die Bewässerungspumpe ein. 
8. System: Nach einer konfigurierten Zeitspanne oder wenn die Bodenfeuchtigkeit einen bestimmten Wert erreicht hat, sendet das Hauptprogramm einen Befehl an das Aktor-Modul, um die Pumpe auszuschalten. 
9. System: Das Aktor-Modul schaltet die Bewässerungspumpe aus. 
6.3 Konfiguration des Systems
1. Aktor: Benutzer 
2. Aktion: Der Benutzer navigiert im Webinterface zur Konfigurationsseite. 
3. System: Das Webinterface-Modul zeigt die Konfigurationsformulare an. 
4. Aktor: Der Benutzer ändert die Konfigurationseinstellungen (z.B. Sensor-IDs, Aktor-Namen, Schwellwerte). 
5. Aktor: Der Benutzer speichert die Konfiguration. 
6. System: Das Webinterface-Modul sendet die neuen Konfigurationseinstellungen an das Hauptprogramm. 
7. System: Das Hauptprogramm validiert die Konfigurationseinstellungen und speichert sie in der Datenbank. 
8. System: Das Hauptprogramm benachrichtigt die entsprechenden Module über die geänderten Konfigurationseinstellungen. 
9. System: Die Module passen ihr Verhalten an die neuen Einstellungen an.

7. Verteilungssicht
Der Intelligente Grow Controller ist für den Einsatz auf einem einzelnen Raspberry Pi konzipiert. Alle Software-Komponenten (Module) werden auf dem Raspberry Pi ausgeführt. Die Kommunikation mit den Sensoren und Aktoren erfolgt über die entsprechenden Schnittstellen des Raspberry Pi (I2C, GPIO). Das Webinterface ist über das lokale Netzwerk zugänglich. 

7.1 Hardware-Diagramm 



7.2 Software-Diagramm


7.3 Kommunikationswege
I2C:
Die Sensor-Module kommunizieren über I2C mit dem Raspberry Pi. 
GPIO:
Die Aktor-Module werden über die GPIO-Pins des Raspberry Pi gesteuert. 
HTTP/WebSockets:
Das Webinterface kommuniziert über HTTP/WebSockets mit dem Hauptprogramm. 
SQLite:
Das Hauptprogramm und das Webinterface-Modul greifen auf die SQLite-Datenbank zu. 
7.4 Netzwerk
Der Grow Controller wird in der Regel in einem lokalen Netzwerk eingesetzt. Das Webinterface ist über die IP-Adresse des Raspberry Pi im lokalen Netzwerk erreichbar. Eine Anbindung an das Internet ist optional und kann für bestimmte Funktionen (z.B. Updates) erforderlich sein.
7.5 Deployment
Die Software wird auf dem Raspberry Pi installiert, indem die entsprechenden Dateien (Python-Skripte, Django-Projekt) auf den Raspberry Pi kopiert werden. Die Konfiguration erfolgt über das Webinterface oder durch manuelle Bearbeitung der Konfigurationsdateien.


8. Implementierungssicht.
8.1 Code-Struktur
Der Quellcode des Grow Controllers ist in folgende Verzeichnisse unterteilt:
??? core
?   ??? __init__.py
?   ??? main.py
?   ??? config.py
??? webinterface
?   ??? __init__.py
?   ??? urls.py
?   ??? views.py
?   ??? templates
?   ?   ??? dashboard.html
?   ??? static
?       ??? styles.css
??? sensors
?   ??? __init__.py
?   ??? dht22.py
?   ??? ds18b20.py
?   ??? base_sensor.py
??? actors
?   ??? __init__.py
?   ??? relay.py
?   ??? pwm.py
?   ??? base_actor.py
??? database
?   ??? __init__.py
?   ??? models.py
?   ??? db_setup.py
??? update
?   ??? __init__.py
?   ??? update_manager.py
?   ??? rollback.py
??? plugins
?   ??? __init__.py
??? tests
    ??? __init__.py
    ??? test_sensors.py
    ??? test_actors.py
    ??? test_webinterface.py
Beschreibung der Verzeichnisse:
core: Enthält den Kern des Systems, einschließlich des Hauptprogramms und der Konfigurationslogik.
webinterface: Beinhaltet den Code für das Webinterface, inklusive URLs, Views, Templates und statische Dateien.
sensors: Implementierung der Sensor-Module. Jedes Sensormodul wird in einer eigenen Datei definiert.
actors: Implementierung der Aktor-Module. Jedes Aktormodul wird in einer eigenen Datei definiert.
database: Definiert die Struktur und die Zugriffslogik für die SQLite-Datenbank.
update: Beinhaltet die Implementierung für die Update- und Rollback-Funktionalität.
plugins: Implementierung für das Plugin-System, das neue Module dynamisch lädt und verwaltet.
tests: Beinhaltet Unit- und Integrationstests für die verschiedenen Module.

Für die Benennung von Dateien, Klassen und Funktionen werden folgende Konventionen verwendet:
Dateinamen:
snake_case (z.B. main.py, sensor_module.py) 
Klassennamen:
CamelCase (z.B. SensorModule, WebServer) 
Funktionsnamen:
snake_case (z.B. get_temperature, set_relay_state) 
8.2 Module und Komponenten
Jedes Modul ist in mehrere Klassen und Funktionen unterteilt, die für die jeweilige Funktionalität verantwortlich sind. Zum Beispiel:
Sensor-Modul:
base_sensor.py
python
class SensorModule:
    def read_value(self):
        raise NotImplementedError("This method should be overridden by subclasses")
dht22.py
python
import Adafruit_DHT
from base_sensor import SensorModule

class DHT22Module(SensorModule):
    def __init__(self, pin):
        self.sensor = Adafruit_DHT.DHT22
        self.pin = pin

    def read_value(self):
        humidity, temperature = Adafruit_DHT.read_retry(self.sensor, self.pin)
        return {'temperature': temperature, 'humidity': humidity}
Aktor-Modul:
base_actor.py
class ActorModule:
    def set_state(self, state):
        raise NotImplementedError("This method should be overridden by subclasses")
relay.py
import RPi.GPIO as GPIO
from base_actor import ActorModule

class RelayModule(ActorModule):
    def __init__(self, pin):
        self.pin = pin
        GPIO.setup(self.pin, GPIO.OUT)

    def set_state(self, state):
        GPIO.output(self.pin, 

Webinterface-Modul:* 
Django-Projekt mit verschiedenen Apps für die Darstellung der Benutzeroberfläche, die Konfiguration und die Diagramme. 
8.3 Bibliotheken und Frameworks
Folgende Bibliotheken und Frameworks werden verwendet:
Python:
Python 3.9+ als Programmiersprache. 
Django:
Django als Webframework für die Entwicklung des Webinterfaces. 
SQLite:
SQLite als Datenbank für die Speicherung der Konfiguration und der Sensordaten.

Adafruit_DHT:
Bibliothek zur Ansteuerung von DHT22 Sensoren. 
Rpi.GPIO:
Bibliothek zur Steuerung der GPIO-Pins des Raspberry Pi.

8.4 Datenstrukturen und Algorithmen
Listen und Dictionaries:
Zur Speicherung und Verwaltung der Sensordaten.
Matplotlib oder Plotly:
Für die Erstellung von Diagrammen zur Visualisierung historischer Sensordaten.

8.5 Schnittstellen
Die Schnittstellen zwischen den Modulen werden durch Funktionsaufrufe und Datenaustausch im JSON-Format realisiert.
# JSON-Datenstruktur für Sensordaten
sensor_data = {
    "temperature": 22.5,
    "humidity": 45.0
}

# JSON-Datenstruktur für Aktorzustand
actor_state = {
    "relay": True
}

8.6 Teststrategie
Unit-Tests und Integrationstests werden durchgeführt, um die Funktionsfähigkeit der einzelnen Module und deren Interaktion sicherzustellen. Die Testabdeckung wird durch eine Code-Coverage-Analyse sichergestellt.
test_sensors.py
import unittest
from sensors.dht22 import DHT22Module

class TestDHT22Module(unittest.TestCase):
    def test_read_value(self):
        sensor = DHT22Module(pin=4)
        result = sensor.read_value()
        self.assertIn('temperature', result)
        self.assertIn('humidity', result)

if __name__ == '__main__':
    unittest.main()

8.7 Build-Prozess
Der Build-Prozess umfasst das Kompilieren des Django-Projekts und das Verpacken der Software in eine ausführbare Datei oder ein Installationspaket. Dies kann durch Tools wie pyinstaller für Python erreicht werden. 
8.8 Deployment
Die Software wird auf dem Raspberry Pi installiert, indem die Dateien auf den Raspberry Pi kopiert werden. Die Konfiguration erfolgt über das Webinterface oder durch manuelle Bearbeitung der Konfigurationsdateien.
8.9 Code-Beispiele
(Hier können relevante Code-Beispiele eingefügt werden, um die Implementierung wichtiger Aspekte zu veranschaulichen.)

9. Daten
9.1 Datenmodell
Das Datenmodell des Grow Controllers umfasst folgende Entitäten:
Sensor:* 
Attribute: id (eindeutige ID), name, type (z.B. Temperatur, Luftfeuchtigkeit), pin (GPIO-Pin), unit (z.B. °C, %), calibration_offset 
Aktor:* 
Attribute: id (eindeutige ID), name, type (z.B. Relais, PWM), pin (GPIO-Pin), state (Ein/Aus) 
Benutzer:* 
Attribute: username, password_hash, role (z.B. Administrator, Benutzer) 
Messwert:* 
Attribute: timestamp, sensor_id, value 
Konfiguration:* 
Attribute: key, value (z.B. WLAN-Einstellungen, Schwellwerte, Zeitpläne) 
Die Beziehungen zwischen den Entitäten sind wie folgt:
Ein Sensor kann mehrere Messwerte haben. 
Ein Aktor hat einen Zustand. 
Ein Benutzer hat eine Rolle. 
Die Konfiguration enthält Schlüssel-Wert-Paare. 
(Hier könnte ein UML-Klassendiagramm oder ein Entity-Relationship-Diagramm eingefügt werden, um das Datenmodell zu visualisieren.)
9.2 Datenformate
Die Daten werden in folgenden Formaten verwendet:
JSON:
Für den Austausch von Daten zwischen den Komponenten (z.B. Sensorwerte, Konfigurationseinstellungen). JSON ist ein leichtgewichtiges und einfach zu parsendes Format, das sich gut für Webanwendungen eignet. 
SQLite:
Für die Speicherung der Daten in der Datenbank. SQLite ist eine relationale Datenbank, die sich gut für kleinere Projekte eignet. 
9.3 Datenquellen
Die Daten stammen von folgenden Quellen:
Sensoren:
Die Sensoren erfassen die Umgebungsbedingungen (Temperatur, Luftfeuchtigkeit, Bodenfeuchtigkeit) und liefern die entsprechenden Messwerte. 
Benutzer:
Der Benutzer gibt Konfigurationseinstellungen über das Webinterface ein. 
9.4 Datenspeicherung
Die Daten werden in der SQLite-Datenbank gespeichert. Die Datenbank enthält Tabellen für die oben genannten Entitäten (Sensoren, Aktoren, Benutzer, Messwerte, Konfiguration). Die Messwerte werden in einer separaten Tabelle gespeichert, um eine effiziente Abfrage der historischen Daten zu ermöglichen. Die Konfigurationseinstellungen werden in einer Tabelle mit Schlüssel-Wert-Paaren gespeichert.
Die Daten werden so lange aufbewahrt, bis sie vom Benutzer gelöscht werden. Es könnte eine Funktion implementiert werden, um alte Daten automatisch zu löschen (z.B. nach einem bestimmten Zeitraum oder bei Erreichen einer bestimmten Datenmenge).
9.5 Datenzugriff
Auf die Daten wird über das Hauptprogramm zugegriffen. Das Hauptprogramm stellt Schnittstellen für den Zugriff auf die Daten bereit. Das Webinterface-Modul nutzt diese Schnittstellen, um die Daten anzuzeigen und zu verarbeiten.
Der Zugriff auf die Daten ist durch eine rollenbasierte Zugriffskontrolle geschützt. Nur autorisierte Benutzer (z.B. Administratoren) haben Zugriff auf alle Daten.
9.6 Datenschutz
Die persönlichen Daten der Benutzer (Benutzername, Passwort) werden durch eine rollenbasierte Zugriffskontrolle geschützt. Die Passwörter werden mit einem sicheren Hash-Algorithmus (z.B. bcrypt) verschlüsselt gespeichert.
Es werden keine sensiblen Daten über die Pflanzenumgebung gespeichert, die Rückschlüsse auf die Identität des Benutzers zulassen würden.
Die Datenschutzbestimmungen (z.B. DSGVO) werden eingehalten. Es wird eine Datenschutzerklärung erstellt, die die Benutzer über die Datenerfassung und -verarbeitung informiert.
9.7 Datenqualität
Die Qualität der Daten wird durch folgende Maßnahmen sichergestellt:
Validierung:
Die vom Benutzer eingegebenen Konfigurationseinstellungen werden validiert (z.B. Format, Länge, Wertebereich). 
Plausibilitätsprüfung:
Die von den Sensoren erfassten Messwerte werden auf Plausibilität geprüft (z.B. Wertebereich, Änderungsrate). 
Fehlerbehandlung:
Fehler bei der Datenerfassung oder -verarbeitung werden protokolliert und dem Benutzer angezeigt. 
9.8 Datenmenge
Das System muss voraussichtlich mit folgenden Datenmengen umgehen:
Konfiguration:
Die Konfiguration ist relativ klein (wenige Kilobyte). 
Messwerte:
Die Menge der Messwerte hängt von der Anzahl der Sensoren und der Erfassungshäufigkeit ab. Bei einer Erfassung alle 5 Minuten und 10 Sensoren entstehen ca. 2.900 Messwerte pro Tag. 
Benutzerdaten:
Die Menge der Benutzerdaten ist in der Regel klein (wenige Kilobyte). 
Das System ist in der Lage, diese Datenmengen zu verarbeiten. Die SQLite-Datenbank ist für diese Datenmengen ausreichend dimensioniert. Bei Bedarf könnte auf eine andere Datenbank migriert werden, um größere Datenmengen zu verarbeiten.

10. Schlüsselentscheidungen
Im Folgenden sind die wichtigsten Entscheidungen zusammengefasst, die während des Architekturentwurfs getroffen wurden:
10.1 Modulare Architektur:
Entscheidung:
Wir haben uns für eine modulare Architektur entschieden. 
Begründung:
Die modulare Architektur bietet die größte Flexibilität für die Erweiterung und Wartung des Systems. Neue Funktionen können in separaten Modulen implementiert werden, ohne den Kern des Systems zu verändern. Dies erhöht die Wartbarkeit und reduziert das Risiko von unerwünschten Seiteneffekten bei Änderungen. Zudem ermöglicht die modulare Architektur die Integration von Open-Source-Modulen/Plugins, was für unser Projekt ein wichtiger Aspekt ist. 
Konsequenzen:
Die modulare Architektur erfordert die Definition klarer Schnittstellen zwischen den Modulen. Dies ist zwar mit einem gewissen Aufwand verbunden, zahlt sich aber durch die erhöhte Flexibilität und Wartbarkeit aus. 
10.2 Technologieauswahl:
Entscheidung:
Wir verwenden Python 3.9+ mit Django als Webframework und SQLite als Datenbank. 
Begründung:
Python ist eine weit verbreitete und gut unterstützte Sprache mit einer großen Community und vielen Bibliotheken für die Entwicklung von Webanwendungen und die Ansteuerung von Hardware-Komponenten. Django ist ein ausgereiftes und sicheres Webframework, das uns viele Funktionen für die Entwicklung komplexer Webanwendungen bietet. SQLite ist eine einfache und leichtgewichtige Datenbank, die sich gut für die Speicherung der Konfiguration und der Sensordaten eignet. 
Konsequenzen:
Die Verwendung von Python und Django ermöglicht uns eine schnelle und effiziente Entwicklung des Webinterfaces und der Ansteuerung der Hardware-Komponenten. SQLite ist für die erwartete Datenmenge ausreichend und unkompliziert in der Handhabung. 
10.3 Datenmanagement:
Entscheidung:
Wir verwenden SQLite zur Speicherung der Konfiguration, der Sensordaten und der Aktorzustände. 
Begründung:
SQLite ist eine leichtgewichtige und embedded Datenbank, die sich gut für den Einsatz auf einem Raspberry Pi eignet. Sie ist einfach zu installieren und zu konfigurieren und bietet dennoch ausreichend Funktionalität für unser Projekt. 
Konsequenzen:
Die Verwendung von SQLite ermöglicht uns eine einfache und unkomplizierte Datenhaltung. Für den Fall, dass die Anforderungen an die Datenbank in Zukunft steigen, könnten wir auf eine andere Datenbank migrieren. 
10.4 Sicherheit:
Entscheidung:
Wir implementieren eine rollenbasierte Zugriffskontrolle mit Passwortschutz. 
Begründung:
Eine rollenbasierte Zugriffskontrolle ermöglicht es uns, verschiedene Benutzerrollen mit unterschiedlichen Berechtigungen zu definieren. Dadurch können wir sicherstellen, dass nur autorisierte Benutzer auf bestimmte Funktionen oder Daten zugreifen können. Die Verschlüsselung der Passwörter mit einem sicheren Hash-Algorithmus schützt die Passwörter vor unbefugtem Zugriff. 
Konsequenzen:
Die Implementierung einer rollenbasierten Zugriffskontrolle erfordert einen gewissen Aufwand bei der Entwicklung. Die Verschlüsselung der Passwörter mit einem sicheren Hash-Algorithmus ist jedoch relativ einfach zu implementieren und bietet einen hohen Sicherheitsgewinn. 
10.5 Update-Mechanismus:
Entscheidung:
Wir implementieren eine Update-Funktion mit Rollback-Möglichkeit. 
Begründung:
Die Update-Funktion ermöglicht es uns, das System einfach und sicher zu aktualisieren. Die Rollback-Funktion stellt sicher, dass das System im Fehlerfall nicht beschädigt wird. 
Konsequenzen:
Die Implementierung der Update-Funktion und der Rollback-Funktion erfordert einen gewissen Entwicklungsaufwand.

11. Komerzielle Strategie
Zielgruppe
Die Zielgruppe für das GrowintelliPi Projekt umfasst:
Hobbygärtner: Menschen, die Pflanzen in Innenräumen anbauen, wie z.B. in Grow-Zelten oder Gewächshäusern.
Professionelle Züchter: Unternehmen oder Einzelpersonen, die Pflanzen professionell anbauen und dabei Technologie zur Überwachung und Steuerung einsetzen möchten.
Forschungseinrichtungen: Einrichtungen, die Pflanzenwachstum und -bedingungen zu Forschungszwecken überwachen und steuern müssen.
Bildungseinrichtungen: Schulen und Universitäten, die intelligente Systeme für Unterricht und Forschung im Bereich der Pflanzenwissenschaften einsetzen.
Produktpositionierung
Das Produkt wird wie folgt positioniert:
Open-Source-Version: Das Grundprogramm und die grundlegendsten Module werden unter eine Open-Source-Lizenz gestellt, um eine breite Nutzerbasis zu erreichen und Community-Beteiligung zu fördern.
Kommerzielle Module: Weitere spezialisierte Module, wie z.B. für Statistik-Auswertungen oder Aqua/Hydroponik, werden gegen eine einmalige Gebühr verkauft. Diese Gebühr enthält Updates und Support für ein Jahr. Danach kann die Lizenz erneuert werden, um weiterhin Updates und Support zu erhalten, muss aber nicht.
Community-Version: Eine Open-Source-Version, die grundlegende Funktionen bietet.
Kommerzielle Version: Eine Version mit erweiterten Funktionen und Support, die als Lizenzmodell oder günstigeres Abonnementmodell angeboten wird.
Wertversprechen: Zeitersparnis, verbesserte Erträge und verbesserter Support für kommerzielle Versionen.
Preisgestaltung
Die Preisgestaltung könnte wie folgt aussehen:
Einmalige Lizenzgebühr: Für spezialisierte Module, einschließlich eines Jahres Support und Updates.
Abonnementmodell: Monatliches oder jährliches Abonnement für erweiterte Funktionen und regelmäßige Updates.
Gestaffelte Preise: Verschiedene Preisstufen für Basisversion, Pro-Version und Unternehmensversion.
Marketingstrategie
Zu Beginn konzentrieren wir uns auf Online-Marketing und Partnerschaften:
Online-Marketing: Nutzung von Social Media, Google Ads und Content-Marketing (Blog-Beiträge, Videos).
Partnerschaften: Zusammenarbeit mit Herstellern von Grow-Zubehör, Gartencentern und Online-Shops.
Vertriebskanäle
Es werden mehrere Vertriebskanäle genutzt:
Online-Shop: Direkter Verkauf über eine eigene Website oder Plattformen wie Amazon.
Vertriebspartner: Zusammenarbeit mit Vertriebspartnern, die das Produkt in ihrem Sortiment führen.
Direktvertrieb: Spezielle Vertriebsmitarbeiter oder Vertreter für den B2B-Markt (professionelle Züchter, Forschungseinrichtungen).
Kunden-Support
Der Support wird auf folgende Weise bereitgestellt:
E-Mail-Support: Schneller und effizienter Support per E-Mail.
Online-Dokumentation: Umfassende Online-Dokumentation mit häufigen Fragen und Schritt-für-Schritt-Anleitungen.
Community-Forum: Ein Forum, in dem Benutzer Fragen stellen und sich gegenseitig helfen können.
Telefon-Support: Wird aufgrund von Kapital- und Personalbeschränkungen nicht angeboten.
Partnerschaften
Potenzielle Partner, die das Projekt unterstützen können, sind:
Hardware-Hersteller: Kooperationen, um günstiger an benötigte Hardware zu gelangen.
Anbieter von Grow-Zubehör: Zusammenarbeit für den Vertrieb des Produkts.
Bildungseinrichtungen: Als Abnehmer und für wertvolles Feedback.



12. Technische Umsetzung
12.1 Ordnerstrucktur
Growcontroller/
??? core/ # Kernfunktionen und Hauptlogik
? ???__init__.py
? ??? main.py # Hauptprogramm
? ??? config.py # Konfiguration
??? webinterface/ # Webinterface-bezogene Dateien
? ???__init__.py
? ??? views.py # Logik für die Webseiten
? ??? urls.py # URLs für die Webseiten
? ??? templates/ # HTML-Vorlagen
? ??? static/ # CSS, JavaScript, Bilder
??? sensors/ # Module für die Sensoranbindung
? ???__init__.py
? ??? dht22.py # Beispiel: DHT22-Sensor
? ??? ... # Weitere Sensoren
??? actors/ # Module für die Aktoransteuerung
? ???__init__.py
? ??? relay.py # Beispiel: Relais-Ansteuerung
? ??? ... # Weitere Aktoren
??? database/ # Datenbankbezogene Dateien
? ???__init__.py
? ??? models.py # Datenbankmodelle
? ??? db_setup.py # Datenbankinitialisierung
??? update/ # Update-Funktionalität
? ???__init__.py
? ??? updater.py # Logik für Updates
??? plugins/ # Plugins und Erweiterungen
? ???__init__.py
??? tests/ # Tests für die einzelnen Module
? ???__init__.py
? ??? test_sensors.py
? ??? …
??? ... # Weitere Dateien (z.B. README, requirements.txt)



12.2 Wireframes

Vor dem erstellen der Wireframes für die einzelnen Ansichten werden zunächst alle ansichten identifiziert.
Dashboard: Übersicht über aktuelle Sensorwerte, Zustand der Aktoren, etc. 
Konfiguration: Einstellungen für Sensoren, Aktoren, Zeitpläne, etc. 
Diagramme: Anzeige von historischen Sensorwerten in Diagrammen. 
Logdateien: Anzeige der Logdateien des Systems. 
Update: Seite für die Update-Funktion. 
12.2.1 Dashboard



12.2.2 Konfiguration




12.2.3 Diagramme



12.2.4 Logdateien


12.2.5 Update



12.2.6 Hilfe


13. Glossar
Aktor: Eine Komponente, die eine Aktion ausführt (z.B. ein Relais, das ein Licht ein- und ausschaltet, oder ein Motor, der eine Pumpe antreibt).
API (Application Programming Interface): Eine Schnittstelle, die es verschiedenen Softwarekomponenten ermöglicht, miteinander zu kommunizieren und Daten auszutauschen.
Authentifizierung: Der Prozess der Überprüfung der Identität eines Benutzers (z.B. durch Eingabe von Benutzername und Passwort).
Autorisierung: Der Prozess der Zuweisung von Berechtigungen an einen Benutzer oder eine Komponente (z.B. Zugriff auf bestimmte Funktionen oder Daten).
Datenbank: Ein System zur elektronischen Speicherung und Verwaltung von Daten.
Django: Ein Open-Source-Webframework, das in Python geschrieben wurde und die Entwicklung von Webanwendungen vereinfacht.
DSGVO (Datenschutz-Grundverordnung): Eine EU-Verordnung zum Schutz personenbezogener Daten.
Embedded System: Ein Computersystem, das in ein größeres System integriert ist und spezielle Aufgaben erfüllt (z.B. ein Mikrocontroller in einem Haushaltsgerät).
GPIO (General Purpose Input/Output): Pins an einem Mikrocontroller (wie dem Raspberry Pi), die für verschiedene Zwecke verwendet werden können (z.B. zum Ansteuern von Aktoren oder zum Auslesen von Sensoren).
Hardware: Die physischen Komponenten eines Systems (z.B. Computer, Sensoren, Aktoren).
I2C (Inter-Integrated Circuit): Ein serielles Datenübertragungsprotokoll, das häufig für die Kommunikation zwischen Mikrocontrollern und Sensoren verwendet wird.
JSON (JavaScript Object Notation): Ein leichtgewichtiges Datenformat, das für den Austausch von Daten zwischen Systemen verwendet wird.
Konfiguration: Die Einstellungen und Parameter, die das Verhalten eines Systems bestimmen.
Latenz: Die Zeitverzögerung zwischen einer Aktion und der Reaktion darauf.
Modul: Eine in sich geschlossene Einheit von Code oder Hardware, die eine bestimmte Funktion erfüllt.
Open Source: Software, deren Quellcode öffentlich zugänglich ist und die in der Regel frei verwendet, verändert und weitergegeben werden kann.
Performance: Die Leistungsfähigkeit eines Systems (z.B. Reaktionszeit, Durchsatz).
Plugin: Eine Erweiterung, die einem System hinzugefügt werden kann, um neue Funktionen zu ermöglichen.
PWM (Pulsweitenmodulation): Eine Technik zur Steuerung der Leistung von elektrischen Geräten (z.B. LEDs) durch Variation der Breite von Pulsen.
Raspberry Pi: Ein kleiner, kostengünstiger Einplatinencomputer, der häufig für Projekte im Bereich der Heimautomatisierung und des Internets der Dinge (IoT) verwendet wird.
Repository: Ein zentraler Speicherort für Dateien und deren Versionsgeschichte (z.B. auf GitHub oder GitLab).
RFID (Radio-Frequency Identification): Eine Technologie zur drahtlosen Identifizierung von Objekten mithilfe von Radiowellen.
Sicherheit: Der Schutz von Systemen und Daten vor unbefugtem Zugriff, Manipulation oder Zerstörung.
Sensor: Eine Komponente, die eine physikalische Größe (z.B. Temperatur, Feuchtigkeit) erfasst und in ein elektrisches Signal umwandelt.
Software: Die Programme und Daten, die auf einem Computersystem ausgeführt werden.
Skalierbarkeit: Die Fähigkeit eines Systems, mit einer wachsenden Anzahl von Benutzern, Daten oder Anforderungen umzugehen.
Update: Die Aktualisierung einer Software oder Hardware auf eine neuere Version.
Webinterface: Eine Benutzeroberfläche, die über einen Webbrowser zugänglich ist.



14. Änderungsprotokoll

Version
Datum
Beschreibung der Änderung
1.0.0
08.02.25
Initialisierung des Dokuments
1.0.1
09.02.25
Mit weiteren Daten stark erweitert, Umfang von 6 auf 34 Seiten gestiegen.
1.0.2
14.02.25
Einige Verbesserungen und Abschnitt Kommerzielle Strategie zu gefügt.










